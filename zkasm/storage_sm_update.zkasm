Update:

    ${GetRKey()} => RKEY                                    ; LOAD FREE ${GetRKey()} -> RKEY;

    ; OldRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( OldValue[0-3], OldValue[4-7] ) ) )
    ${GetOldValueLow()} => VALUE_LOW                        ; LOAD FREE ${GetOldValueLow()} -> VALUE_LOW;
    VALUE_LOW => HASH_LEFT                                  ; LOAD VALUE_LOW -> HASH_LEFT;
    ${GetOldValueHigh()} => VALUE_HIGH                      ; LOAD FREE ${GetOldValueHigh()} -> VALUE_HIGH;
    VALUE_HIGH => HASH_RIGHT                                ; LOAD VALUE_HIGH -> HASH_RIGHT;
    $ => HASH_RIGHT                 :HASH                   ; HASH -> HASH_RIGHT;
    RKEY => HASH_LEFT                                       ; LOAD RKEY -> HASH_LEFT;
    $ => HASH_RIGHT                 :HASH                   ; HASH -> HASH_RIGHT;
    0x1 => HASH_LEFT                                        ; LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
    $ => OLD_ROOT                   :HASH                   ; HASH -> OLD_ROOT;

    ; NewRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( NewValue[0-3], NewValue[4-7] ) ) )
    ${GetValueLow()} => VALUE_LOW                           ; LOAD FREE ${GetValueLow()} -> VALUE_LOW;
    VALUE_LOW => HASH_LEFT                                  ; LOAD VALUE_LOW -> HASH_LEFT;
    ${GetValueHigh()} => VALUE_HIGH                         ; LOAD FREE ${GetValueHigh()} -> VALUE_HIGH;
    VALUE_HIGH => HASH_RIGHT                                ; LOAD VALUE_HIGH -> HASH_RIGHT;
    $ => HASH_RIGHT                 :HASH                   ; HASH -> HASH_RIGHT;
    RKEY => HASH_LEFT                                       ; LOAD RKEY -> HASH_LEFT;
    $ => HASH_RIGHT                 :HASH                   ; HASH -> HASH_RIGHT;
    0x1 => HASH_LEFT                                        ; LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
    $ => NEW_ROOT                   :HASH                   ; HASH -> NEW_ROOT;

    ; Init LEVEL, and rotate as per key level
    0x01 => LEVEL                                           ; LOAD FREE ${GetConstant(1,0,0,0)} -> LEVEL;
    ${GetLevelBit(0)}               :JMPZ(Update_LevelBit1) ; JMPZ FREE ${GetLevelBit(0)} -> Update_LevelBit1; // If level bit 0 is zero, then skip the next 1 rotation
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

Update_LevelBit1:

    ${GetLevelBit(1)}               :JMPZ(Update_ClimbTree) ; JMPZ FREE ${GetLevelBit(1)} -> Update_ClimbTree; // If level bit 1 is zero, then skip the next 2 rotations
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

Update_ClimbTree:
    ${GetTopTree()}                 :JMPZ(Update_Latch)     ; JMPZ FREE ${GetTopTree()} -> Update_Latch; // If (we are at the top of the tree) goto Update_Latch

    ${GetNextKeyBit()} => RKEY_BIT                          ; LOAD FREE ${GetNextKeyBit()} -> RKEY_BIT;
    RKEY_BIT                        :JMPZ(Update_SiblingIsRight2) ; JMPZ RKEY_BIT -> Update_SiblingIsRight2; // If next key bit is zero, then sibling is right (sibling's next key bit is 1)

Update_SiblingIsLeft2:

    ; NewRoot = Hash ( SiblingHash, NewRoot )
    NEW_ROOT => HASH_RIGHT                                  ; LOAD NEW_ROOT -> HASH_RIGHT;
    ${GetSiblingHash()} => HASH_LEFT                        ; LOAD FREE ${GetSiblingHash()} -> HASH_LEFT;
    $ => NEW_ROOT                   :HASH                   ; HASH -> NEW_ROOT;

    ; OldRoot = Hash ( SiblingHash, OldRoot )
    OLD_ROOT => HASH_RIGHT                                  ; LOAD OLD_ROOT -> HASH_RIGHT;
    $ => OLD_ROOT                   :HASH                   ; HASH -> OLD_ROOT;

    ; Update remaining key
                                    :CLIMB_RKEY             ; CLIMB_RKEY;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

                                    :JMP(Update_ClimbTree)  ; JMP Update_ClimbTree;

Update_SiblingIsRight2:

    ; NewRoot = Hash ( NewRoot, SiblingHash )
    NEW_ROOT => HASH_LEFT                                   ; LOAD NEW_ROOT -> HASH_LEFT;
    ${GetSiblingHash()} => HASH_RIGHT                       ; LOAD FREE ${GetSiblingHash()} -> HASH_RIGHT;
    $ => NEW_ROOT                   :HASH                   ; HASH -> NEW_ROOT;

    ; OldRoot = Hash ( OldRoot, SiblingHash )
    OLD_ROOT => HASH_LEFT                                   ; LOAD OLD_ROOT -> HASH_LEFT;
    $ => OLD_ROOT                   :HASH                   ; HASH -> OLD_ROOT;

    ; Update remaining key
                                    :CLIMB_RKEY             ; CLIMB_RKEY;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

                                    :JMP(Update_ClimbTree)  ; JMP Update_ClimbTree;


Update_Latch:
                                    :LATCH_SET              ; At this point consistency is granted: OLD_ROOT, NEW_ROOT, RKEY (complete key), VALUE_LOW, VALUE_HIGH, LEVEL