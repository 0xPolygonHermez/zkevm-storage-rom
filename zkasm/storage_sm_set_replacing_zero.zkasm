Set_ReplacingZero:

    ${GetRKey()} => RKEY

    ; OldRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( Value[0-3], Value[4-7] ) ) );
    ${GetValueLow()} => VALUE_LOW
    VALUE_LOW => HASH_LEFT
    ${GetValueHigh()} => VALUE_HIGH
    VALUE_HIGH => HASH_RIGHT
    $ => HASH_RIGHT                 :HASH0
    RKEY => HASH_LEFT
    $ => HASH_RIGHT                 :HASH0
    0x1 => HASH_LEFT
    $ => OLD_ROOT                   :HASH1

    ; Init LEVEL, and rotate as per key level
    0x1 => LEVEL
    ${GetLevelBit(0)}               :JMPZ(SRZ_LevelBit1)    ; If level bit 0 is zero, then skip the next 1 rotation
                                    :ROTATE_LEVEL

SRZ_LevelBit1:

    ${GetLevelBit(1)}               :JMPZ(SRZ_SiblingHash)  ; If level bit 1 is zero, then skip the next 2 rotations
                                    :ROTATE_LEVEL
                                    :ROTATE_LEVEL

SRZ_SiblingHash:

    ${GetNextKeyBit()} => RKEY_BIT
    RKEY_BIT                        :JMPZ(SRZ_SiblingIsRight1) ; If next key bit is zero, then sibling is right (sibling's next key bit is 1)
 
SRZ_SiblingIsLeft1:

    ; NewRoot = Hash( SiblingHash, OldRoot(LeafNodeHash) )
    OLD_ROOT => HASH_RIGHT
    ${GetSiblingHash()} => HASH_LEFT
    $ => NEW_ROOT                   :HASH0

    ; OldRoot = Hash ( SiblingHash, 0 )
    0x0 => HASH_RIGHT
    $ => OLD_ROOT                   :HASH0

    ; Update remaining key
                                    :CLIMB_RKEY
                                    :ROTATE_LEVEL

                                    :JMP(SRZ_ClimbTree)

SRZ_SiblingIsRight1:

    ; NewRoot = Hash( OldRoot(LeafNodeHash), SiblingHash )
    OLD_ROOT => HASH_LEFT
    ${GetSiblingHash()} => HASH_RIGHT
    $ => NEW_ROOT                   :HASH0

    ; OldRoot = Hash ( 0, SiblingHash )
    0x0 => HASH_LEFT
    $ => OLD_ROOT                   :HASH0

    ; Update remaining key
                                    :CLIMB_RKEY
                                    :ROTATE_LEVEL

SRZ_ClimbTree:
    ${GetTopTree()}                 :JMPZ(SRZ_Latch)        ; If (we are at the top of the tree) goto SRZ_Latch

    ${GetNextKeyBit()} => RKEY_BIT
    RKEY_BIT                        :JMPZ(SRZ_SiblingIsRight2) ; If next key bit is zero, then sibling is right (sibling's next key bit is 1)

SRZ_SiblingIsLeft2:

    ; NewRoot = Hash ( SiblingHash, NewRoot )
    NEW_ROOT => HASH_RIGHT
    ${GetSiblingHash()} => HASH_LEFT
    $ => NEW_ROOT                   :HASH0

    ; OldRoot = Hash ( SiblingHash, OldRoot )
    OLD_ROOT => HASH_RIGHT
    $ => OLD_ROOT                   :HASH0

    ; Update remaining key
                                    :CLIMB_RKEY
                                    :ROTATE_LEVEL

                                    :JMP(SRZ_ClimbTree)

SRZ_SiblingIsRight2:

    ; NewRoot = Hash ( NewRoot, SiblingHash )
    NEW_ROOT => HASH_LEFT
    ${GetSiblingHash()} => HASH_RIGHT
    $ => NEW_ROOT                   :HASH0

    ; OldRoot = Hash ( OldRoot, SiblingHash )
    OLD_ROOT => HASH_LEFT
    $ => OLD_ROOT                   :HASH0

    ; Update remaining key
                                    :CLIMB_RKEY
                                    :ROTATE_LEVEL

                                    :JMP(SRZ_ClimbTree)


SRZ_Latch:
                                    :LATCH_SET              ; At this point consistency is granted: OLD_ROOT, NEW_ROOT, RKEY (complete key), VALUE_LOW, VALUE_HIGH, LEVEL
                                    :JMP(Run)