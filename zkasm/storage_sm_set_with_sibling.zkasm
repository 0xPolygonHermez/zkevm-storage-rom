Set_WithSibling:

    ${GetRKey()} => RKEY
    ${GetSiblingRKey()} => SIBLING_RKEY

    ; NewRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( Value[0-3], Value[4-7] ) ) );
    ${GetValueLow()} => VALUE_LOW
    VALUE_LOW => HASH_LEFT
    ${GetValueHigh()} => VALUE_HIGH
    VALUE_HIGH => HASH_RIGHT
    $ => HASH_RIGHT                 :HASH
    RKEY => HASH_LEFT
    $ => HASH_RIGHT                 :HASH
    0x1=> HASH_LEFT
    $ => NEW_ROOT                   :HASH

    ; OldRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( SiblingValue[0-3], SiblingValue[4-7] ) ) );
    ${GetSiblingValueLow()} => HASH_LEFT
    ${GetSiblingValueHigh()} => HASH_RIGHT
    $ => SIBLING_VALUE_HASH         :HASH
    SIBLING_VALUE_HASH => HASH_RIGHT
    RKEY => HASH_LEFT
    $ => HASH_RIGHT                 :HASH
    0x1 => HASH_LEFT
    $ => NEW_ROOT                   :HASH

    ; Init LEVEL, and rotate as per key level
    0x1 => LEVEL
    ${GetLevelBit(0)}               :JMPZ(SWS_LevelBit1)    ; If level bit 0 is zero, then skip the next 1 rotation
                                    :ROTATE_LEVEL

SWS_LevelBit1:

    ${GetLevelBit(1)}               :JMPZ(SWS_SiblingHash)  ; If level bit 1 is zero, then skip the next 2 rotations
                                    :ROTATE_LEVEL
                                    :ROTATE_LEVEL

SWS_SiblingHash:

    ${GetNextKeyBit()} => RKEY_BIT
    RKEY_BIT                        :JMPZ(SWS_SiblingIsRight1) ; If next key bit is zero, then sibling is right (sibling's next key bit is 1)

SWS_SiblingIsLeft1:

    ; NewRoot = Hash( SiblingHash, LeafNodeHash )
    OLD_ROOT => HASH_LEFT
    NEW_ROOT => HASH_RIGHT
    $ => NEW_ROOT                   :HASH

                                    :JMP(SWS_ClimbBranch)

SWS_SiblingIsRight1:

    ; NewRoot = Hash( LeafNodeHash, SiblingHash )
    NEW_ROOT => HASH_LEFT
    OLD_ROOT => HASH_RIGHT
    $ => NEW_ROOT                   :HASH

SWS_ClimbBranch:

    ${GetTopOfBranch()}             :JMPZ(SWS_StartOldRoot) ; If we are at the top of the branch, then go to SWS_StartOldRoot

                                    :CLIMB_RKEY
                                    :CLIMB_SIBLING_RKEY
                                    :ROTATE_LEVEL

    ${GetNextKeyBit()} => RKEY_BIT
    RKEY_BIT                        :JMPZ(SWS_SiblingIsRight2)

SWS_SiblingIsLeft2:

    ; NewRoot = Hash ( SiblingHash, NewRoot )
    ${GetSiblingHash()} => HASH_LEFT
    NEW_ROOT => HASH_RIGHT
    $ => NEW_ROOT                   :HASH

                                    :JMP(SWS_ClimbBranch)

SWS_SiblingIsRight2:

    ; NewRoot = Hash ( NewRoot, SiblingHash )
    NEW_ROOT => HASH_LEFT
    ${GetSiblingHash()} => HASH_RIGHT
    $ => NEW_ROOT                   :HASH

                                    :JMP(SWS_ClimbBranch)

SWS_StartOldRoot:
    ; OldRoot = Hash( 1 | 0 | 0 | 0, Hash( SiblingKey, Hash( SiblingValue[0-3], SiblingValue[4-7] ) ) );
    SIBLING_VALUE_HASH => HASH_RIGHT
    SIBLING_RKEY => HASH_LEFT
    $ => HASH_RIGHT                 :HASH
    0x1 => HASH_LEFT
    $ => OLD_ROOT                   :HASH

SWS_ClimbTree:
    ${GetTopOfTree()}               :JMPZ(SWS_Latch)        ; If we are at the top of the tree, then go to SWS_Latch

    ${GetNextKeyBit()} => RKEY_BIT
    RKEY_BIT                        :JMPZ(SWS_SiblingIsRight2)

SWS_SiblingIsLeft3:

    ; NewRoot = Hash ( SiblingHash, NewRoot )
    NEW_ROOT => HASH_RIGHT
    ${GetSiblingHash()} => HASH_LEFT
    $ => NEW_ROOT                   :HASH

    ; OldRoot = Hash ( SiblingHash, OldRoot )
    OLD_ROOT => HASH_RIGHT
    $ => OLD_ROOT                   :HASH

    ; Update remaining key
                                    :CLIMB_RKEY
                                    :ROTATE_LEVEL

                                    :JMP(SWS_ClimbTree)

SWS_SiblingIsRight3:

    ; NewRoot = Hash ( NewRoot, SiblingHash )
    NEW_ROOT => HASH_LEFT
    ${GetSiblingHash()} => HASH_RIGHT
    $ => NEW_ROOT                   :HASH

    ; OldRoot = Hash ( OldRoot, SiblingHash )
    OLD_ROOT => HASH_LEFT
    $ => OLD_ROOT                   :HASH

    ; Update remaining key
                                    :CLIMB_RKEY
                                    :ROTATE_LEVEL

                                    :JMP(SWS_ClimbTree)

SWS_Latch:
                                    :LATCH_SET              ; At this point consistency is granted: OLD_ROOT, NEW_ROOT, RKEY (complete key), VALUE_LOW, VALUE_HIGH, LEVEL