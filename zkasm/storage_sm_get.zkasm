Get:

    ; Root Node (same as before)                # end of tree
    ;  / \                                      |
    ;     Intermediate Node (same as before)    ^ climb tree
    ;      / \                                  |
    ;         Leaf Value Node (same as before)  * start here

    ; During a get operation we have 2 different cases:
    ;
    ; 1.- We found the key and a non-zero value
    ;     We have to create the value hash entry and the corresponding leaf node
    ;     that will be the first value of old root, and then climb the tree up to the top
    ;
    ; 2.- We could not find the key, and therefore value is zero
    ;     We have to start with old root = 0, and then climb the tree up to the top
    ;     In case we are already at the top (no siblings) the old root will remain 0

    ; Get the remaining key
    ${GetRKey()} => RKEY

    ; Get the retrieved value
    ; If value is 0, skip the leaf node creation and go to Get_ValueIsZero

    ${getValueLow()} => VALUE_LOW, VALUE_HIGH :JMPZ(Get_VL0IsZero)
                                              :JMP(Get_ValueLowIsNotZero)

Get_VL0IsZero:
    ROTL_VH => VALUE_HIGH       :JMPZ(Get_VL01IsZero)
                                :JMP(Get_ValueLowIsNotZero)

Get_VL01IsZero:
    ROTL_VH => VALUE_HIGH       :JMPZ(Get_VL012IsZero)
                                :JMP(Get_ValueLowIsNotZero)

Get_VL012IsZero:
    ROTL_VH => VALUE_HIGH       :JMPZ(Get_VL0123IsZero)
                                :JMP(Get_ValueLowIsNotZero)

Get_VL0123IsZero:
    ${getValueHigh()} => VALUE_HIGH :JMPZ(Get_VL0123VH0IsZero)
                                    :JMP(Get_ValueIsNotZero)

Get_VL0123VH0IsZero:
    ROTL_VH => VALUE_HIGH       :JMPZ(Get_VL0123VH01IsZero)
    ROTL_VH => VALUE_HIGH
    ROTL_VH => VALUE_HIGH
    ROTL_VH => VALUE_HIGH       :JMP(Get_ValueIsNotZero)

Get_VL0123VH01IsZero:
    ROTL_VH => VALUE_HIGH        :JMPZ(Get_VL0123VH012IsZero)
    ROTL_VH => VALUE_HIGH
    ROTL_VH => VALUE_HIGH        :JMP(Get_ValueIsNotZero)

Get_VL0123VH012IsZero:
    ROTL_VH => VALUE_HIGH        :JMPZ(Get_ValueIsZero)
    ROTL_VH => VALUE_HIGH        :JMP(Get_ValueIsNotZero)

Get_ValueLowIsNotZero:
    ${getValueHigh()} => VALUE_HIGH

Get_ValueIsNotZero:

    ; Create the value hash and the leaf node hash, which will be the initial value of old root

    ; ValueHash = Hash0( VALUE_LOW, VALUE_HIGH )
    VALUE_LOW => HASH_LEFT
    VALUE_HIGH => HASH_RIGHT
    $ => HASH_RIGHT                 :HASH0

    ; OldRoot = LeafNodeHash = Hash1( RKey, Hash( VALUE_LOW, VALUE_HIGH ) )
    RKEY => HASH_LEFT
    $ => OLD_ROOT                   :HASH1

                                    :JMP(Get_InitLevel)

Get_ValueIsZero:

    ; No need to calculate the hash; the next intermediate node will use simply 0 as a hash
    0x0 => OLD_ROOT

Get_InitLevel:

    ; Init LEVEL register to {1,0,0,0}, and inversely rotate it level%4 times,
    ; so that after level rotations the position of LEVEL becomes {1,0,0,0} again
    0x1 => LEVEL

    ; If level bit 0 is 1, then do 1 inverse rotation (i.e. 3 normal rotations)
    ${GetLevelBit(0)}               :JMPZ(Get_LevelBit1)
                                    :ROTATE_LEVEL
                                    :ROTATE_LEVEL
                                    :ROTATE_LEVEL

Get_LevelBit1:

    ; If level bit 1 is 1, then do 2 inverse rotations (i.e. 2 normal rotations)
    ${GetLevelBit(1)}               :JMPZ(Get_ClimbTree)
                                    :ROTATE_LEVEL
                                    :ROTATE_LEVEL

Get_ClimbTree:

    ; If we are at the top of the tree, then goto Get_Latch
    ${GetTopTree()}                 :JMPZ(Get_Latch)

    ; If next key bit is zero, then the sibling hash must be at the right (sibling's key bit is 1)
    ${GetNextKeyBit()} => RKEY_BIT
    RKEY_BIT                        :JMPZ(Get_SiblingIsRight)

Get_SiblingIsLeft:

    ; OldRoot = Hash0( SiblingHash, OldRoot );
    ${GetSiblingHash()} => HASH_LEFT
    OLD_ROOT => HASH_RIGHT
    $ => OLD_ROOT                   :HASH0

    ; Update remaining key
                                    :ROTATE_LEVEL
                                    :CLIMB_RKEY

                                    :JMP(Get_ClimbTree)

Get_SiblingIsRight:

    ; OldRoot = Hash0( OldRoot, SiblingHash );
    OLD_ROOT => HASH_LEFT
    ${GetSiblingHash()} => HASH_RIGHT
    $ => OLD_ROOT                   :HASH0

    ; Update remaining key
                                    :ROTATE_LEVEL
                                    :CLIMB_RKEY

                                    :JMP(Get_ClimbTree)

Get_Latch:

    ; At this point consistency is granted: OLD_ROOT, RKEY (complete key), VALUE_LOW, VALUE_HIGH, LEVEL
                                    :LATCH_GET

    ; Return to the main loop
                                    :JMP(Run)